---
title: "Искусство «распикселивания»: как приручить AI-пиксель-арт"
subtitle: "Глубокий разбор компьютерного зрения в unfake.js"
author: "unfake.js team"
date: "2024"
tags: ["computer-vision", "pixel-art", "AI", "image-processing", "javascript"]
---

# Искусство «распикселивания»: как приручить AI-пиксель-арт

С появлением генеративных нейросетей интернет наводнили новые «пиксельные» картинки. На первый взгляд — чистый ретро-арт, но на самом деле это не настоящая пиксельная графика. AI не думает дискретными пикселями и не ограничен палитрой: он «рисует» высокоразрешённое изображение, которое только выглядит как пиксель-арт.

Из-за этого возникают уникальные проблемы: «пиксели» разного размера, сетка плавает, а вместо 16 цветов — тысячи оттенков. Если просто уменьшить такое изображение, получится мыльная каша.

В этой статье мы разберём пайплайн unfake.js — инструмента, который превращает хаос AI-арта в чистый, пригодный для работы пиксель-арт.

## Главная проблема: иллюзия сетки

Вот наш подопытный — AI-сгенерированный гусь:

![Исходное изображение](images/goose_ai.png)
*Наш объект: красивый, но хаотичный AI-арт.*

AI как бы «целится» в сетку 43×43, но не попадает. Если наложить на картинку наивную сетку 43×43 (от 0,0), видно хаос:

![Сетка не совпадает](images/intro_grid_overlay_misaligned.png)
*Наивная сетка (красная) не совпадает с «пикселями» AI.*

Если сдвинуть сетку оптимально, становится лучше, но всё равно не идеально:

![Сетка с оптимальным сдвигом](images/intro_grid_overlay_aligned.png)
*Оптимально сдвинутая сетка (зелёная). Всё равно пиксели AI не вписываются идеально.*

Даже если сетка совпала, пиксели внутри неё всё равно «плавают». Если просто уменьшить картинку по сетке, получится вот так:

![Наивный даунскейл](images/intro_nearest_neighbor_upscaled.png)
*Наивное уменьшение и увеличение. Всё ломается, потому что у AI нет настоящей пиксельной сетки.*

Последняя проблема — иллюзия палитры. То, что кажется одним цветом, на самом деле десятки оттенков. Простое уменьшение только усугубит ситуацию.

---

## Решение: пайплайн из 5 этапов

```mermaid
graph TD
    A["AI-арт<br/>Тысячи цветов<br/>Плавающая сетка"] --> B["1. Поиск масштаба<br/>Edge-aware анализ"]
    B --> C["2. Выравнивание по сетке<br/>Оптимальный сдвиг"]
    C --> D["3. Квантизация палитры<br/>K-Means до 16 цветов"]
    D --> E["4. Даунскейл<br/>Dominant color"]
    E --> F["5. Финальная очистка<br/>Бинарная альфа, шум"]
    F --> G["Чистый пиксель-арт<br/>Идеальная сетка<br/>Ограниченная палитра"]
    style A fill:#ffcccc
    style G fill:#ccffcc
    style B fill:#cceeff
    style C fill:#cceeff
    style D fill:#cceeff
    style E fill:#cceeff
    style F fill:#cceeff
```

---

## Этап 1: Поиск масштаба (Scale Detection)

Для надёжного поиска масштаба unfake.js анализирует несколько информативных тайлов по всей картинке и «голосует» за наиболее вероятный размер сетки. Это защищает от локального шума и артефактов.

Чтобы показать общую картину, мы строим распределение расстояний между пиками по всему изображению:

![Распределение расстояний по всей картинке](images/matplotlib_spacings_full_image_ru.png)
*Анализ всей картинки даёт сотни измерений. Явно видно, что AI целился в шаг 43 пикселя.*

Также можно визуализировать, где AI создавал самые сильные границы между «пикселями»:

![Карта градиентов](images/full_image_gradient_heatmap.png)
*Яркие области — сильные границы. Регулярный паттерн подтверждает корректность детекции сетки.*

---

## Этап 2: Выравнивание по сетке

Зная масштаб, мы подбираем оптимальный сдвиг, чтобы сетка максимально совпала с содержимым:

![Обрезка по сетке](images/chapter2_cropped_with_grid.png)
*После обрезки размеры идеально делятся на масштаб.*

---

## Этап 3: Квантизация палитры

AI-арт содержит тысячи оттенков, которые выглядят как простая палитра. Мы группируем их с помощью K-Means:

![Исходная палитра](images/chapter3_palette_before.png)
*До квантизации: сотни цветов, плавные переходы.*

![Квантизированная палитра](images/chapter3_palette_after.png)
*После квантизации: чистая палитра из 16 цветов.*

---

## Этап 4: Даунскейл по доминирующему цвету

Теперь мы уменьшаем картинку, выбирая для каждого блока самый частый цвет (или средний, если нет явного лидера):

| 1. Блок | 2. Анализ цветов | 3. Победитель |
| :---: | :---: | :---: |
| ![Блок](images/chapter2_demo_block.png) | ![Гистограмма](images/chapter2_demo_tally.png) | ![Победитель](images/chapter2_demo_winner.png) |

---

## Этап 5: Финальная очистка и палитра

После даунскейла мы:
- Делаем альфу бинарной
- Убираем шум и одиночные пиксели

### Финальный результат

![Финальный результат](images/chapter2_final_result_upscaled.png)
*Чистый пиксель-арт, увеличенный для наглядности.*

### Финальная палитра

После всех этапов в финальной картинке остаются только эти цвета:

![Финальная палитра](images/final_palette.png)
*Реальная палитра итогового изображения. Остались только самые нужные цвета.*

---

## Технический отчёт

```
Scale detected: 43
Optimal crop offset: x=23, y=22
Cropped image size: 989 x 989
Original palette size: 25116 colors
Quantized palette size: 16 colors
Blocks: 23 x 23
Demo block dominant color: #09a67a (50.1%)
Fallback to mean color: No
```

---

## Примеры

![Сравнение 1](images/example_1_comparison.png)
![Сравнение 2](images/example_2_comparison.png)
![Сравнение 3](images/example_3_comparison.png)
![Сравнение 4](images/example_4_comparison.png)

---

## Заключение

AI-пиксель-арт — это смесь ретро-стиля и хаоса. unfake.js превращает этот хаос в структурированный, пригодный для работы пиксель-арт:  
- Находит масштаб и сетку  
- Квантизирует палитру  
- Умно уменьшает и очищает  
- Оставляет только нужные цвета

В результате получается картинка, которую не стыдно использовать в играх, анимации и творчестве.

---
