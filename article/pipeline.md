# Пайплайн Визуализации Алгоритмов unfake.js

Бро, здорово! Чтобы ты не путался в том, что мы наворотили в `visualizer.html`, я составил эту шпаргалку. Здесь подробно расписан каждый этап нашей визуализации и какая картинка за что отвечает.

## Часть 1: Демонстрация алгоритма `downscaleByDominantColor`

Здесь мы показываем, как работает наш основной алгоритм уменьшения, от большой картинки до финального результата.

### Шаг 1: Подготовка и общая картина

*   **Что делаем:** Загружаем исходное изображение и показываем, как мы его делим на блоки.
*   **Визуализации:**
    *   `Source Image`: Исходник, как он есть.
    *   `1. Grid Overlay`: Та же картинка, но с наложенной сеткой. Размер ячейки сетки (`scale`) — это тот самый масштаб, который мы либо задали вручную, либо определили автоматически.

### Шаг 2: Анализ "Интересных" Блоков (в цикле)

Мы не берем случайный блок. Мы находим 3 самых детализированных блока и для каждого из них показываем весь процесс.

*   **Как находим:** Функция `findInterestingBlocks` пробегается по всем блокам и считает для каждого "стандартное отклонение" (variance). Чем выше это значение, тем больше в блоке разных цветов и деталей. Мы берем топ-3.
*   **Что делаем для каждого блока (например, для блока №1):**
    1.  **Показываем сам блок.**
        *   **Визуализация:** `1.1. Interesting Block (Variance: ...)` — Увеличенное изображение самого блока. В названии мы даже пишем его `variance`, чтобы было видно, насколько он "интересный".
    2.  **Считаем цвета.**
        *   **Визуализация:** `1.2. Color Tally` — Список всех цветов, найденных в этом блоке, и количество пикселей каждого цвета.
    3.  **Определяем победителя.**
        *   **Визуализация:** `1.3. Dominant Color Result` — Один большой пиксель, окрашенный в доминирующий цвет (тот, которого в блоке было больше всего).

*(Этот цикл повторяется для визуализаций 2.1, 2.2, 2.3 и 3.1, 3.2, 3.3)*

### Шаг 3: Финальная сборка и сравнение

*   **Что делаем:** Показываем результат работы алгоритма на всей картинке и сравниваем его с примитивным методом.
*   **Визуализации:**
    *   `5. Full Dominant Color Result`: Итоговое изображение, уменьшенное с помощью нашего алгоритма `downscaleByDominantColor`.
    *   `6. Nearest Neighbor Comparison`: Изображение, уменьшенное самым простым методом ("ближайший сосед"). Сделано для контраста, чтобы показать, насколько наш метод лучше сохраняет детали.

---

## Часть 2: Демонстрация алгоритма определения масштаба `edgeAwareDetect`

Здесь мы объясняем, как наш "умный" метод находит тот самый `scale` (в нашем случае `43`).

### Шаг 1: Выбор "подопытного"

*   **Что делаем:** Мы не анализируем всю картинку целиком, а берем для демонстрации один показательный участок.
*   **Визуализация:** `7. Analysis Tile` — Участок изображения размером 150x150, на котором мы будем показывать магию.

### Шаг 2: Поиск границ (Градиенты Собеля)

*   **Что делаем:** Используем математический фильтр (оператор Собеля) для поиска резких переходов цвета.
*   **Визуализации:**
    *   `8. Sobel X Gradient (Vertical Edges)`: На этой картинке белым подсвечены все **вертикальные** границы пикселей.
    *   `9. Sobel Y Gradient (Horizontal Edges)`: Здесь, соответственно, подсвечены **горизонтальные** границы.

### Шаг 3: Измерение расстояния между границами (Профили)

*   **Что делаем:** Превращаем 2D-карты границ в 1D-графики, чтобы наглядно увидеть расстояние между ними.
*   **Визуализации:**
    *   `10. Horizontal Profile (Sum of X-Gradient)`: Этот график показывает "силу" вертикальных границ в каждой колонке пикселей. Ты увидишь четкие пики через равные промежутки.
    *   `11. Vertical Profile (Sum of Y-Gradient)`: То же самое, но для горизонтальных границ в каждой строке.
*   **Главный вывод:** Расстояние между пиками на этих графиках и есть наш **автоматически определенный масштаб!**

Надеюсь, эта шпаргалка поможет тебе, бро! Теперь ты точно не запутаешься. 